---
title: Unified diff viewer
description: An opinionated simple diff viewer for React. 
---

<Preview
  id="overview"
  label="Unified diff"
  description="A real git patch rendered with grouping heuristics."
  src="/previews/diff-viewer/overview"
>
The unified diff viewer parses standard unified diffs and renders them as minimally as possible. It merges nearby insertions and deletions into a single “modified” row and shows small character-level edits inline to make it easier to understand changes.  

Below is documentation for how to use it, and an in-depth explanation of how it works. To the right, you can see the DiffViewer component. During the in-depth explanation you will see how we go from a verbose Github style diff, to a more minimal diff.
</Preview>

## Installation

```bash
npx shadcn@latest add https://ui.fredrika.dev/r/diff-viewer.json
```

## Usage

Use `parseDiff` to convert a diff string into a list of files. Passing `children` to the `Diff` is optional, just passing the `hunks` is fine too.

```tsx
import { parseDiff } from "@/ui/diff/utils";
import { Diff, Hunk, Link } from "@/ui/diff";

const DiffViewer = ({ diff }: { diff: string }) => {
  const files = parseDiff(diff);

  return (
    <div>
      {files.map((file) => (
        <Diff key={file.name} hunks={file.hunks}>
          {file.hunks.map((hunk) => (
            <Hunk key={hunk.id} hunk={hunk} />
          ))}
        </Diff>
      ))}
    </div>
  );
};
```

## Parsing diffs

<Preview
  id="github"
  label="GitHub baseline"
  description="Shows the raw diff without any grouping."
  src="/previews/diff-viewer/github"
>
This is how GitHub would show this diff. Inserted and deleted blocks are rendered separately, sometimes far apart. 
Take a look at line 4, where the `ChevronDown` icon is added to the import. You need to read two lines to understand that only an icon was added and nothing deleted.

```diff
- import { Check, Copy } from "lucide-react";
+ import { Check, Copy, ChevronDown } from "lucide-react";
```
{/* TODO: explain the diff format */}
</Preview>

<Preview
  id="merged"
  label="Merge adjacent lines"
  description="Adjacent insertions and deletions are grouped together."
  src="/previews/diff-viewer/merged"
>
Now look at line 4 again. The separate insert and delete are merged together, making it much easier to understand what changed. 

The naive approach is to iterate over all changes and merge adjacent insertions and deletions into one "normal" line where segments are marked as `insert` or `delete`.

```ts
const mergeAdjacentLines = (changes: _Change[]): Line[] => {
  const out: Line[] = [];
  for (let i = 0; i < changes.length; i++) {
    const current = changes[i];
    const next = changes[i + 1];
    if (current.type === "delete" && next?.type === "insert") {
      out.push({
        ...current,
        type: "normal",
        isNormal: true,
        oldLineNumber: current.lineNumber,
        newLineNumber: next.lineNumber,
        content: buildInlineDiffSegments(current, next),
      });
      i++; // Skip next
    } else {
      out.push(current);
    }
  }

  return out;
};
```

</Preview>

<Preview
  id="dissimilarRaw"
  label="No change ratio limit"
  description="Highly dissimilar lines create noise without extra heuristics."
  src="/previews/diff-viewer/dissimilarRaw"
>
The problem with just merging *every* delete+insert pair is that when the lines are very different, the result is noisy. See line 6 – not very nice. 

To solve this, we can add a maximum change ratio. So only lines where the change ratio is less than this limit are merged.

```ts
const calculateChangeRatio = (a: string, b: string): number => {
  const totalChars = a.length + b.length;
  if (totalChars === 0) return 1;
  const tokens = diffWords(a, b);
  const changedChars = tokens
    .filter((token) => token.added || token.removed)
    .reduce((sum, token) => sum + token.value.length, 0);
  return changedChars / totalChars;
};

// Then we check for it before merging
if (current.type === "delete" && next.type === "insert" 
  && calculateChangeRatio(current.content, next.content) < options.maxChangeRatio) { /* ... */ }
```
</Preview>

<Preview
  id="dissimilar"
  label="Max change ratio"
  description="Similar lines are merged even when they are not adjacent."
  src="/previews/diff-viewer/dissimilar"
>
Setting the max change ratio to `0.45` prevents the parser from merging line 6. Try playing with it to see what happens.

But deletions and insertions of modified lines are not always next to each other. Look at line 23. The deleted version of that line is displayed below line 42, making it very difficult to see that the only change is adding `min-h-16`.

What if we find the best possible match for each deletion while maintaining the order? 
</Preview>

<Preview
  id="complexMerged"
  label="Large diff · Merge adjacent"
  description="Adjacent blocks are merged to trim repeated context."
  src="/previews/diff-viewer/complexMerged"
>

Now look at line 23 again. The separate insert and delete are merged together, making it much easier to understand what changed. 

But why isn't the small typo that was fixed by adding `x` merged together? Try increasing the inline max char edits to see how it works.

```ts
const charDiff = diffCharsIfWithinEditLimit(
  current.value,
  next.value,
  options.inlineMaxCharEdits
);

if (!charDiff.exceededLimit) {
  charDiff.diffs.forEach(mergeIntoResult);
  i++;
} else {
  result.push(current);
}
```
</Preview>

