---
title: Unified diff viewer
description: An opinionated simple diff viewer for React. 
ogImage: "/unified-diff-viewer.png"
---

Built for [asi.review](https://asi.review), but available as a standalone component.

<Preview
  id="overview"
  label="Unified diff"
  description="A real git patch rendered with grouping heuristics."
  src="/previews/diff-viewer/overview"
>
The unified diff viewer parses standard unified diffs and renders them as minimally as possible. It merges nearby insertions and deletions into a single “modified” row and shows small character-level edits inline to make it easier to understand changes.  

Below is documentation for how to use it, and an in-depth explanation of how it works. To the right, you can see the DiffViewer component. During the in-depth explanation you will see how we go from a verbose Github style diff, to a more minimal diff.
</Preview>


## Installation

```bash
npx shadcn@latest add https://ui.fredrika.dev/r/diff-viewer.json
```

View the source code on [GitHub](https://github.com/fredrikalindh/ui/tree/main/registry/ui/diff)

## Usage

Use `parseDiff` to convert a diff string into a list of files. Passing `children` to the `Diff` is optional, just passing the `hunks` is fine too.

```tsx
import { parseDiff } from "@/ui/diff/utils";
import { Diff, Hunk, Link } from "@/ui/diff";

const DiffViewer = ({ diff }: { diff: string }) => {
  const files = parseDiff(diff);

  return (
    <div>
      {files.map((file) => (
        <Diff key={file.name} hunks={file.hunks}>
          {file.hunks.map((hunk) => (
            <Hunk key={hunk.id} hunk={hunk} />
          ))}
        </Diff>
      ))}
    </div>
  );
};
```

<Preview
  id="github"
  label="GitHub baseline"
  description="Shows the raw diff without any grouping."
  src="/previews/diff-viewer/github"
>
## Parsing diffs
GitHub shows diffs without merging modified lines. Inserted and deleted blocks are rendered separately, sometimes far apart. 
Take a look at line 4, where the `ChevronDown` icon is added to the import. You need to read two lines to understand that only an icon was added and nothing deleted.

```diff
- import { Check, Copy } from "lucide-react";
+ import { Check, Copy, ChevronDown } from "lucide-react";
```
{/* TODO: explain the diff format */}
</Preview>

<Preview
  id="merged"
  label="Merge adjacent lines"
  description="Adjacent insertions and deletions are grouped together."
  src="/previews/diff-viewer/merged"
>
Now look at line 4 again. The separate insert and delete are merged together, making it much easier to understand what changed. 

The naive approach is to iterate over all changes and merge adjacent insertions and deletions into one "normal" line where segments are marked as `insert` or `delete`.

```ts
const mergeAdjacentLines = (changes: _Change[]): Line[] => {
  const out: Line[] = [];
  for (let i = 0; i < changes.length; i++) {
    const current = changes[i];
    const next = changes[i + 1];
    if (current.type === "delete" && next?.type === "insert") {
      out.push({
        ...current,
        type: "normal",
        isNormal: true,
        oldLineNumber: current.lineNumber,
        newLineNumber: next.lineNumber,
        content: buildInlineDiffSegments(current, next),
      });
      i++; // Skip next
    } else {
      out.push(current);
    }
  }

  return out;
};
```

</Preview>

<Preview
  id="dissimilarRaw"
  label="No change ratio limit"
  description="Highly dissimilar lines create noise without extra heuristics."
  src="/previews/diff-viewer/dissimilarRaw"
>
The problem with just merging *every* delete+insert pair is that when the lines are very different, the result is noisy. See line 6 – not very nice. 

To solve this, we can add a maximum change ratio. So only lines where the change ratio is less than this limit are merged.

```ts
const calculateChangeRatio = (a: string, b: string): number => {
  const totalChars = a.length + b.length;
  if (totalChars === 0) return 1;
  const tokens = diffWords(a, b);
  const changedChars = tokens
    .filter((token) => token.added || token.removed)
    .reduce((sum, token) => sum + token.value.length, 0);
  return changedChars / totalChars;
};

// Then we check for it before merging
if (current.type === "delete" && next.type === "insert" 
  && calculateChangeRatio(current.content, next.content) < options.maxChangeRatio) { /* ... */ }
```
</Preview>

<Preview
  id="dissimilar"
  label="Max change ratio"
  description="Similar lines are merged even when they are not adjacent."
  src="/previews/diff-viewer/dissimilar"
>
Setting the max change ratio to `0.45` prevents the parser from merging line 6. Try playing with it to see what happens.

But deletions and insertions of modified lines are not always next to each other. Look at line 20. The deleted version of that line is displayed below line 38, making it very difficult to see that the only change is adding `min-h-16`.

What if we find the best possible match for each deletion while maintaining the order? 
</Preview>

<Preview
  id="complexMerged"
  label="Large diff · Merge adjacent"
  description="Adjacent blocks are merged to trim repeated context."
  src="/previews/diff-viewer/complexMerged"
>

Now look at line 20 again. The separate insert and delete are merged together, making it much easier to understand what changed. 

But why isn't the small typo that was fixed by adding `x` merged together? Try increasing the inline max char edits to see how it works.

```ts
const charDiff = diffCharsIfWithinEditLimit(
  current.value,
  next.value,
  options.inlineMaxCharEdits
);

if (!charDiff.exceededLimit) {
  charDiff.diffs.forEach(mergeIntoResult);
  i++;
} else {
  result.push(current);
}
```
</Preview>

<Preview
  id="wordDiff"
  label="Word diff"
  description="Using `git diff --word-diff` to make it better."
  src="/previews/diff-viewer/wordDiff"
>

### Using word-diff

Git has another mode for generating diffs called `word-diff`. Github doesn't support this, but you can run it in your terminal like this:

```bash
git diff --word-diff --no-index <old-file> <new-file>
```

Unlike the default Myer's algorithm, word-diff outputs the diff on a word-by-word basis. Each inserted word is wrapped in `{+` and `+}` and each deleted word is wrapped in `[-` and `-]`. So we no longer need to guess which lines are modified. 

Because it's parsing on word-level, we still need to merge adjacent insertions and deletions on each line using the same heuristics as before. 
```diff
import { Check, [-Copy-]{+Copy, ChevronDown+} } from "lucide-react";
```


It does not have any options for when lines are similar enough. Our anti-example will be merged as well:
```diff
import [-{ useTheme }-]{+* as Collapsible+} from [-"next-themes";-]{+"@radix-ui/react-collapsible";+}
```


</Preview>

<Preview
  id="separated"
  label="Separate insertions and deletions"
  description="Separate insertions and deletions on each line."
  src="/previews/diff-viewer/separated"
>

So we can use the same change ratio to split merged lines into separate insertions and deletions.
```ts
// before
import [-{ useTheme }-]{+* as Collapsible+} from [-"next-themes";-]{+"@radix-ui/react-collapsible";+}

// after
[-import { useTheme } from "next-themes";-]
{+import * as Collapsible from "@radix-ui/react-collapsible";+}
```

And that's probably the best results we can get. 
</Preview>

